## 同步逻辑

### libgrape-lite版

| TESS                                                         | DS                                                           |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1：**`PcNet::afterLoadNet()`加载完路网                     |                                                              |
|                                                              | **2：**`DistributedManager::CreateAndQuery(...)`加载路图     |
| **3：**`PcSimulator::beforeStart(...)`开启仿真前             |                                                              |
|                                                              | **4：**`DistributedManager::DoQuery(...)`Grape开始工作       |
|                                                              | **5：**`WorkerJob::IncEval(...)`处理0批次信息                |
| **6：**`PcSimulator::beforeStart(...)`开始仿真               |                                                              |
| **7：**`PcSimulator::afterOneStep(...)`计算完，将本批次驶出信息存放 |                                                              |
|                                                              | **8：**`WorkerJob::IncEval(...)`将驶出信息发送出去           |
| **4：**`PcSimulator::afterOneStep(...)`结束批次              |                                                              |
|                                                              | **5：**`WorkerJob::IncEval(...)`开始接收处理收到的上一批次信息 |
| **6：**`PcSimulator::afterOneStep(...)`开始下一批次          |                                                              |

==循环：7——>8——>4——>5——>6==

- 运行：

  `mpirun -N 1 --allow-run-as-root --hostfile host_info ./TESSNG_Console_linux`

### 自写版：Worker流程

| TESS                                                         | DS                                                           |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1：**`PcNet::afterLoadNet()`构建基础路图                   |                                                              |
|                                                              | **2：**`DistributedThread::doOnInitialing()`接收和确定子路图 |
| **3：**`PcSimulator::beforeStart(...)`开启仿真前             |                                                              |
|                                                              | **4：**`DistributedThread::doOnWorking()::doOneBatch()`开始工作 |
| **5：**`PcSimulator::beforeStart(...)`开始仿真               |                                                              |
| **6：**`PcSimulator::afterOneStep(...)`计算完，将本批次驶出信息存放 |                                                              |
|                                                              | **7：**`DistributedThread::doOnWorking()::doOneBatch()`一批次结束，发送驶出信息 |
|                                                              | **3：**`DistributedThread::doOnWaitting()`邻接点信息接收完成 |
|                                                              | **4：**`DistributedThread::doOnWorking()::doOneBatch()`激活下一批次 |
| **5：**`PcSimulator::afterOneStep(...)`开始下一批次仿真      |                                                              |

==循环：7——>3——>4——>5——>6==

## 批次信息发送逻辑

### 一些要点

- w1完成批次x，意味着：
  - 对方已收到x-1
  - 己方已收全x-1
- w1收到对方的批次x，意味着：
  - 对方已收全x-1，所以一定收到了己方发去的x-1
  - 己方可能只完成了x-1，x还没开始
- w1要求对方重发，满足条件：
  - 己方已仿真完的批次x >= 对方已知仿真的最新批次
  - 己方已仿真完的批次x 已发送过一次，或者说满足超时条件、重发次数条件等。

### 判断流程

1. 先处理对方要求重发的批次
   - 如果，对方批次 > 己方批次，在处理信息时，直接忽略
   - 否则，重发对方批次号对应的信息，后续流程不再处理
2. 己方主动发送信息
   - 如果，是刚产生的批次x（或者还未满足重发超时条件等），发送，并不要求对方回复
   - 否则，发送，并要求对方回复

### Tess客户端

#### TessClient启动流程：

- `startConn2Master()`：向master连接
- `onConnected()`：连接上后，调用`sendInitReq()`，请求初始化信息
- `onRecMessage(...)`：收到master信息，若收到完整的init信息，则调用`init`，否则调用`sendInitReq()`继续请求
- `init`：对kafka初始化，并启动
  - 若是同步：
    - kafka启动后，收到消息，发送最新批次的信号，关联TessClient的槽函数：`doOnNewestBatch(int pid, uint64_t batch)`
    - `doOnNewestBatch(...)`：若得到最新完整的批次号，运行`start()`
  - 若是异步
    - 直接运行`start()`
- `start()`：设置起始批次号
  - 若是同步：
    - 设置：`each_consumer_run->mCurBatch = mSyncCurBatchNum_ = mNewestFullBatch.load() - 1`
  - 若是异步
    - 设置：`each_consumer_run->mCurBatch = run->getNewestBatchNum() - 1`
  - 发送`started(batch)`信号

##TessClientWin运行流程

