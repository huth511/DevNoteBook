## 同步逻辑

### libgrape-lite版

| TESS                                                         | DS                                                           |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1：**`PcNet::afterLoadNet()`加载完路网                     |                                                              |
|                                                              | **2：**`DistributedManager::CreateAndQuery(...)`加载路图     |
| **3：**`PcSimulator::beforeStart(...)`开启仿真前             |                                                              |
|                                                              | **4：**`DistributedManager::DoQuery(...)`Grape开始工作       |
|                                                              | **5：**`WorkerJob::IncEval(...)`处理0批次信息                |
| **6：**`PcSimulator::beforeStart(...)`开始仿真               |                                                              |
| **7：**`PcSimulator::afterOneStep(...)`计算完，将本批次驶出信息存放 |                                                              |
|                                                              | **8：**`WorkerJob::IncEval(...)`将驶出信息发送出去           |
| **4：**`PcSimulator::afterOneStep(...)`结束批次              |                                                              |
|                                                              | **5：**`WorkerJob::IncEval(...)`开始接收处理收到的上一批次信息 |
| **6：**`PcSimulator::afterOneStep(...)`开始下一批次          |                                                              |

==循环：7——>8——>4——>5——>6==

- 运行：

  `mpirun -N 1 --allow-run-as-root --hostfile host_info ./TESSNG_Console_linux`

### 自写版：Worker流程

| TESS                                                         | DS                                                           |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1：**`PcNet::afterLoadNet() #end`构建基础路图              |                                                              |
|                                                              | **2：**`DistributedThread::doOnInitialing() #start`接收和确定子路图 |
| **3：**`PcSimulator::beforeStart(...) #start`开启仿真前      |                                                              |
|                                                              | **4：**`DistributedThread::doOnWorking()::doOneBatch() #start`开始工作 |
| **5：**`PcSimulator::beforeStart(...) #end`开始仿真          |                                                              |
| **6：**`PcSimulator::afterOneStep(...) #start`计算完一批次   |                                                              |
|                                                              | **7：**`DistributedThread::doOneBatch() #end`一批次结束。接下来`doOnWorking`发送out和tail车辆 |
|                                                              | **3：**`DistributedThread::doOnWaitting() #end`邻接点信息接收完成。此时一批次信息才算完整 |
|                                                              | **4：**`DistributedThread::doOneBatch() #start`激活下一批次  |
| **5：**`PcSimulator::afterOneStep(...) #end`开始下一批次仿真 |                                                              |

==循环：7——>3——>4——>5——>6==

## 批次信息发送逻辑

### 一些要点

- w1完成批次x，意味着：
  - 对方已收到x-1
  - 己方已收全x-1
- w1收到对方的批次x，意味着：
  - 对方已收全x-1，所以一定收到了己方发去的x-1
  - 己方可能只完成了x-1，x还没开始
- w1要求对方重发，满足条件：
  - 己方已仿真完的批次x >= 对方已知仿真的最新批次
  - 己方已仿真完的批次x 已发送过一次，或者说满足超时条件、重发次数条件等。

### 判断流程

1. 先处理对方要求重发的批次
   - 如果，对方批次 > 己方批次，在处理信息时，直接忽略
   - 否则，重发对方批次号对应的信息，后续流程不再处理
2. 己方主动发送信息
   - 如果，是刚产生的批次x（或者还未满足重发超时条件等），发送，并不要求对方回复
   - 否则，分以下几种场景进行发送
     - 批次数据之前**已发送**，并**发送失败**。发送后，将其设为**need_resp**（该数据在历史数据容器中的）
     - 当前循环里，**没收到该邻接点的数据**，并且**超时（超过一批次仿真时间）**，那么设为**need_resp**，再发送。
       ==意味着：当前批次，己方已经发送了，但没收到对方的数据==

### Tess客户端

#### TessClient启动流程：

- `startConn2Master()`：向master连接
- `onConnected()`：连接上后，调用`sendInitReq()`，请求初始化信息
- `onRecMessage(...)`：收到master信息，若收到完整的init信息，则调用`init`，否则调用`sendInitReq()`继续请求
- `init`：对kafka初始化，并启动
  - 若是同步：
    - kafka启动后，收到消息，发送最新批次的信号，关联TessClient的槽函数：`doOnNewestBatch(int pid, uint64_t batch)`
    - `doOnNewestBatch(...)`：若得到最新完整的批次号，运行`start()`
  - 若是异步
    - 直接运行`start()`
- `start()`：设置起始批次号
  - 若是同步：
    - 设置：`each_consumer_run->mCurBatch = mSyncCurBatchNum_ = mNewestFullBatch.load() - 1`
  - 若是异步
    - 设置：`each_consumer_run->mCurBatch = run->getNewestBatchNum() - 1`
  - 发送`started(batch)`信号

## TessClientWin运行流程

## 图划分

### Metis

#### 划分步骤

- 根据需要，在TessGraph的基础上，生成GraphLayer

  主要是为了将一些点合在一起，分在一个Tess中。

  - DefaultLayer2：

    - 将面域中的链接段的src路段合成一个TessSuperVertex（继承自TessVertex）。

      - super vertex的id设为`-areaId`

      - super vertex对应的in edge和out edge，是其所包含的原始vertex的edge的合集

    - 没有纳入super vertex的原始vertex不变
    - 更改edge的连接信息，主要将src或dst变更为super vertex的id

- 将GraphLayer key传入`CutGraphWithMetis::initGraphWithLayer(string layer_key)`，将TessVertex，TessEdge，都转为MetisVertex

  - layer中的所有的layer_vertex，layer_edge，都转为图结点MetisVertex对象（**metis_vid**等于layer中的vid或eid）
  - 计算MetisVertex的权重：
    - 若是原始vertex或edge，等于 **对应的路段/连接段的长度 * 其车道数**
    - 若是super vertex，等于 **其所包含的vertex的权重之和**
  - 再用MetisEdge对象连接（edge id从0开始）

- 划分图：`CutGraphWithMetis::cutGraph()`

  - 将MetisVertex，MetisEdge的数据信息，转为metis使用的csr压缩图格式，此时，图结点的id是从0开始的，需要做好映射（与metis_vid的对应关系）。再准备好其它参数，调用其api
  - 返回结果parts数组，等价于kv对：`{vidx: part_id}`

- 根据划分结果parts，返回至Tess

  - 通过vidx确定metis_vid，接着判断其在layer中是什么：
    - 是layer_vertex：
      - 是原始vertex，直接将其分配给对应的node（node_id = part_id + 1）
      - 是super vertex，递归处理其包含的vertex（其也可能是个super vertex）
    - 是layer_edge：
      - 不分配，忽略；存进临时的layer_edge容器中 **[1]**
  - 最后遍历layer_edge容器[1]，根据其对应的原始edge的src，id去算连接关系：nbr信息；node的出边，入边信息等

#### 数据结构变化顺序
```cpp
TessGraph{ TessVertex, TessEdge }	
TessGraphLayer{ TessVertex*(TessVertex, TessSuperVertex), TessEdge* }
CutGraphWithMetis{ MetisVertex, MetisEdge }
Metis数据结构
```



